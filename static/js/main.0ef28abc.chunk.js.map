{"version":3,"sources":["library/utils/deferred.ts","wasm lazy groupOptions: {} namespace object","components/wasm-test-button.tsx","components/app-impl.tsx","App.tsx","serviceWorker.ts","index.tsx","wasm/wasm-loader.ts"],"names":["makeDeferred","deferred","promise","Promise","resolve","webpackEmptyAsyncContext","req","then","e","Error","code","keys","module","exports","id","isNumeric","value","test","WasmTestButton","useState","privateKey","setPrivateKey","isPrivateKeyValid","setIsPrivateKeyValid","message","setMessage","inputSize","setInputSize","currentFelt","setCurrentFelt","signature","setSignature","useEffect","getGlobalWasmState","failedToLoad","waitForWasm","onChange","isInputNumberic","target","Array","fill","map","i","input","onClick","disabled","wasm","getWasmLibIfLoaded","load_sk","toBufferLE","BigInt","felts_le","felt","sig","sign","r","toBigIntLE","toBuffer","get_r","s","get_s","toString","AppImpl","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","console","loadUnsafe","undefined","process","JEST_WORKER_ID","jest","path","__dirname","loadWasmLib","log","StarknetModule","globalDeferredLoad","globalState","isLoading","loadWasm","loadAsyncHelper"],"mappings":"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","file":"static/js/main.0ef28abc.chunk.js","sourcesContent":["// Creates a Promise<void> that will block until resolve is called\nexport function makeDeferred() {\n\ttype Deferred = { promise: Promise<void>; resolve: () => void };\n\tlet deferred: Partial<Deferred> = {};\n\tdeferred.promise = new Promise((resolve) => {\n\t\tdeferred.resolve = resolve;\n\t});\n\treturn deferred as Deferred;\n}\n","function webpackEmptyAsyncContext(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(function() {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t});\n}\nwebpackEmptyAsyncContext.keys = function() { return []; };\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\nmodule.exports = webpackEmptyAsyncContext;\nwebpackEmptyAsyncContext.id = 22;","import React, { useState, useEffect } from 'react';\n\nimport { getGlobalWasmState, getWasmLibIfLoaded } from 'wasm/wasm-loader';\n\nimport toBuffer from 'typedarray-to-buffer';\nimport { toBufferLE, toBigIntLE } from 'bigint-buffer';\n\nimport { joinSignature } from '@ethersproject/bytes';\n\nfunction isNumeric(value: any) {\n\treturn /^-?\\d+$/.test(value);\n}\n\nconst BUFF_LEN = 32;\n\nexport default function WasmTestButton() {\n\tconst [privateKey, setPrivateKey] = useState<string>();\n\tconst [isPrivateKeyValid, setIsPrivateKeyValid] = useState<boolean>(false);\n\n\tconst [message, setMessage] = useState<string[]>([]);\n\tconst [inputSize, setInputSize] = useState<number>(0);\n\tconst [currentFelt, setCurrentFelt] = useState('');\n\n\tconst [signature, setSignature] = useState<{ r: string; s: string }>();\n\n\t// Wait for wasm to be loaded\n\tuseEffect(() => {\n\t\tconst waitForWasm = async () => {\n\t\t\tconst { promise } = getGlobalWasmState();\n\t\t\tawait promise;\n\t\t\tconst { failedToLoad } = getGlobalWasmState();\n\t\t};\n\t\twaitForWasm();\n\t}, []);\n\n\tconst onClick = () => {\n\t\tconst wasm = getWasmLibIfLoaded();\n\t\twasm.load_sk(toBufferLE(BigInt(privateKey!), BUFF_LEN));\n\n\t\tconst felts = message.map((e) => BigInt(e));\n\t\tconst felts_le = felts.map((felt) => toBufferLE(felt, BUFF_LEN));\n\n\t\tif (wasm) {\n\t\t\tconst sig = wasm.sign(felts_le);\n\t\t\tconst r = toBigIntLE(toBuffer(sig.get_r()));\n\t\t\tconst s = toBigIntLE(toBuffer(sig.get_s()));\n\t\t\tsetSignature({ r: r.toString(), s: s.toString() });\n\t\t}\n\t};\n\n\treturn (\n\t\t<div>\n\t\t\t<p>Your private key: </p>\n\t\t\t<input\n\t\t\t\tonChange={(e: any) => {\n\t\t\t\t\tconst isInputNumberic = isNumeric(e.target.value);\n\t\t\t\t\tsetIsPrivateKeyValid(isNumeric(e.target.value));\n\t\t\t\t\tif (isInputNumberic) {\n\t\t\t\t\t\tsetPrivateKey(e.target.value);\n\t\t\t\t\t}\n\t\t\t\t}}\n\t\t\t/>\n\t\t\t<br />\n\t\t\t<a>Key correct: {isPrivateKeyValid ? '✓' : '⛔'}</a>\n\t\t\t<br />\n\n\t\t\t<table>\n\t\t\t\t<tr>\n\t\t\t\t\t<th>Message</th>\n\t\t\t\t</tr>\n\t\t\t\t{new Array(inputSize).fill(0).map((e, i) => (\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<th>Felt {message[i]}</th>\n\t\t\t\t\t</tr>\n\t\t\t\t))}\n\t\t\t\t<div>\n\t\t\t\t\t<input\n\t\t\t\t\t\tonChange={(e: any) => {\n\t\t\t\t\t\t\tconst input = e.target.value as string;\n\t\t\t\t\t\t\tsetCurrentFelt(input);\n\t\t\t\t\t\t}}\n\t\t\t\t\t/>\n\t\t\t\t\t<button\n\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\tif (isNumeric(currentFelt)) {\n\t\t\t\t\t\t\t\tsetMessage([...message, currentFelt]);\n\t\t\t\t\t\t\t\tsetInputSize(inputSize + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}}\n\t\t\t\t\t\tdisabled={!isNumeric(currentFelt)}\n\t\t\t\t\t>\n\t\t\t\t\t\tconfirm\n\t\t\t\t\t</button>\n\t\t\t\t</div>\n\t\t\t</table>\n\t\t\t<br />\n\t\t\t<br />\n\t\t\t<button disabled={!isPrivateKeyValid} onClick={onClick}>\n\t\t\t\tSign\n\t\t\t</button>\n\t\t\t<br />\n\t\t\t<div>\n\t\t\t\t{signature && (\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<a>Signature r: {'0x' + BigInt(signature.r).toString(16)}</a>\n\t\t\t\t\t\t<br />\n\t\t\t\t\t\t<a>Signature s: {'0x' + BigInt(signature.s).toString(16)}</a>\n\t\t\t\t\t</div>\n\t\t\t\t)}\n\t\t\t</div>\n\t\t</div>\n\t);\n}\n","import React from 'react';\n\nimport WasmTestButton from './wasm-test-button';\n\nexport default function AppImpl() {\n\treturn <WasmTestButton />;\n}\n","import React from 'react';\n\nimport AppImpl from './components/app-impl';\n\nconst App = () => <AppImpl />;\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n\twindow.location.hostname === 'localhost' ||\n\t\t// [::1] is the IPv6 localhost address.\n\t\twindow.location.hostname === '[::1]' ||\n\t\t// 127.0.0.0/8 are considered localhost for IPv4.\n\t\twindow.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n);\n\ntype Config = {\n\tonSuccess?: (registration: ServiceWorkerRegistration) => void;\n\tonUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n\tif (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n\t\t// The URL constructor is available in all browsers that support SW.\n\t\tconst publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n\t\tif (publicUrl.origin !== window.location.origin) {\n\t\t\t// Our service worker won't work if PUBLIC_URL is on a different origin\n\t\t\t// from what our page is served on. This might happen if a CDN is used to\n\t\t\t// serve assets; see https://github.com/facebook/create-react-app/issues/2374\n\t\t\treturn;\n\t\t}\n\n\t\twindow.addEventListener('load', () => {\n\t\t\tconst swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n\t\t\tif (isLocalhost) {\n\t\t\t\t// This is running on localhost. Let's check if a service worker still exists or not.\n\t\t\t\tcheckValidServiceWorker(swUrl, config);\n\n\t\t\t\t// Add some additional logging to localhost, pointing developers to the\n\t\t\t\t// service worker/PWA documentation.\n\t\t\t\tnavigator.serviceWorker.ready.then(() => {\n\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t'This web app is being served cache-first by a service ' +\n\t\t\t\t\t\t\t'worker. To learn more, visit https://bit.ly/CRA-PWA'\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Is not localhost. Just register service worker\n\t\t\t\tregisterValidSW(swUrl, config);\n\t\t\t}\n\t\t});\n\t}\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n\tnavigator.serviceWorker\n\t\t.register(swUrl)\n\t\t.then((registration) => {\n\t\t\tregistration.onupdatefound = () => {\n\t\t\t\tconst installingWorker = registration.installing;\n\t\t\t\tif (installingWorker == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tinstallingWorker.onstatechange = () => {\n\t\t\t\t\tif (installingWorker.state === 'installed') {\n\t\t\t\t\t\tif (navigator.serviceWorker.controller) {\n\t\t\t\t\t\t\t// At this point, the updated precached content has been fetched,\n\t\t\t\t\t\t\t// but the previous service worker will still serve the older\n\t\t\t\t\t\t\t// content until all client tabs are closed.\n\t\t\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t\t\t'New content is available and will be used when all ' +\n\t\t\t\t\t\t\t\t\t'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// Execute callback\n\t\t\t\t\t\t\tif (config && config.onUpdate) {\n\t\t\t\t\t\t\t\tconfig.onUpdate(registration);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// At this point, everything has been precached.\n\t\t\t\t\t\t\t// It's the perfect time to display a\n\t\t\t\t\t\t\t// \"Content is cached for offline use.\" message.\n\t\t\t\t\t\t\tconsole.log('Content is cached for offline use.');\n\n\t\t\t\t\t\t\t// Execute callback\n\t\t\t\t\t\t\tif (config && config.onSuccess) {\n\t\t\t\t\t\t\t\tconfig.onSuccess(registration);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\t\t})\n\t\t.catch((error) => {\n\t\t\tconsole.error('Error during service worker registration:', error);\n\t\t});\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n\t// Check if the service worker can be found. If it can't reload the page.\n\tfetch(swUrl, {\n\t\theaders: { 'Service-Worker': 'script' },\n\t})\n\t\t.then((response) => {\n\t\t\t// Ensure service worker exists, and that we really are getting a JS file.\n\t\t\tconst contentType = response.headers.get('content-type');\n\t\t\tif (\n\t\t\t\tresponse.status === 404 ||\n\t\t\t\t(contentType != null && contentType.indexOf('javascript') === -1)\n\t\t\t) {\n\t\t\t\t// No service worker found. Probably a different app. Reload the page.\n\t\t\t\tnavigator.serviceWorker.ready.then((registration) => {\n\t\t\t\t\tregistration.unregister().then(() => {\n\t\t\t\t\t\twindow.location.reload();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Service worker found. Proceed as normal.\n\t\t\t\tregisterValidSW(swUrl, config);\n\t\t\t}\n\t\t})\n\t\t.catch(() => {\n\t\t\tconsole.log('No internet connection found. App is running in offline mode.');\n\t\t});\n}\n\nexport function unregister() {\n\tif ('serviceWorker' in navigator) {\n\t\tnavigator.serviceWorker.ready\n\t\t\t.then((registration) => {\n\t\t\t\tregistration.unregister();\n\t\t\t})\n\t\t\t.catch((error) => {\n\t\t\t\tconsole.error(error.message);\n\t\t\t});\n\t}\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport App from './App';\n\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import path from 'path';\nimport { makeDeferred } from 'library/utils/deferred';\nimport { StarknetModule } from 'starknet-signature';\n\nexport type WasmLibT = typeof import('starknet-signature');\n\nasync function loadUnsafe(): Promise<WasmLibT> {\n\tconst isTest = process.env.JEST_WORKER_ID !== undefined || typeof jest !== 'undefined';\n\n\t// If running test in jest we have to load the node version of the package\n\tif (isTest)\n\t\treturn await import(path.resolve(__dirname, '../../rust-wasm/pkg-node', 'rust_wasm_lib'));\n\treturn await import('starknet-signature');\n}\n\n// Allows the wasm library to be loaded and awaited\nexport async function loadWasmLib() {\n\tlet wasm: WasmLibT | undefined;\n\n\ttry {\n\t\twasm = await loadUnsafe();\n\n\t\tconsole.log('successfully loaded starknet-signature');\n\n\t\tconsole.log(wasm);\n\n\t\t// wasm?.init();\n\t} catch {\n\t\tconsole.log('failed to load starknet-signature');\n\t}\n\n\treturn new wasm!.StarknetModule();\n}\n\nconst globalDeferredLoad = makeDeferred();\n\nconst globalState = {\n\tisLoading: false,\n\tfailedToLoad: false,\n\tpromise: globalDeferredLoad.promise,\n};\n\nexport function getGlobalWasmState() {\n\treturn { ...globalState };\n}\n\nfunction loadAsyncHelper() {\n\tlet wasm: StarknetModule;\n\n\tasync function loadWasm() {\n\t\tglobalState.isLoading = true;\n\n\t\twasm = await loadWasmLib();\n\n\t\tglobalDeferredLoad.resolve();\n\n\t\tglobalState.failedToLoad = wasm === undefined;\n\t\tglobalState.isLoading = false;\n\t}\n\n\tloadWasm();\n\n\treturn () => wasm;\n}\n\n// A function that will return the wasm lib if loaded globally or return undefined if not\nexport const getWasmLibIfLoaded = loadAsyncHelper();\n"],"sourceRoot":""}